
// Generated by CoffeeScript 1.6.3
define('editor_tools/scriptable_toolbar',['require'],function(require) {
  var $, ScriptableToolbar;
  if (typeof $ === "undefined" || $ === null) {
    $ = jQuery;
  }
  return ScriptableToolbar = (function() {
    function ScriptableToolbar(parent, interpreter, root_path) {
      this.interpreter = interpreter;
      this.root_path = root_path;
      this.menuMap = {};
      this.initVisual(parent);
    }

    ScriptableToolbar.prototype.removeItem = function(section, itemName) {
      var _this = this;
      return section["__itemRoot__"].each(function(idx, obj) {
        console.log(obj);
        if ($(obj).data("id") === itemName) {
          return $(obj).clear();
        }
      });
    };

    ScriptableToolbar.prototype.addItem = function(section, itemName, imghRef, helpText, clear) {
      var item, me;
      if (helpText == null) {
        helpText = "";
      }
      if (clear == null) {
        clear = false;
      }
      me = this;
      item = $("<div>").addClass("ribbon-button").attr("style", "float:left");
      if (clear) {
        item.attr("style", item.attr("style") + ";clear:both");
      }
      item.append($("<span>").addClass("button-help").text(helpText));
      if (imghRef.indexOf("http") !== 0) {
        imghRef = this.root_path + imghRef;
      }
      item.append($("<img>").addClass("ribbon-icon").attr("src", imghRef));
      item.data("id", itemName);
      $(item).click(function() {
        var impl;
        impl = me.interpreter.getImplementation(itemName);
        if (impl == null) {
          return;
        }
        return impl();
      });
      $(item).mousedown(function(evt) {
        if (evt.which !== 3) {

        }
      });
      return section["__itemRoot__"].append(item);
    };

    ScriptableToolbar.prototype.addSection = function(menu, sectionName) {
      var itemRoot;
      if (menu[sectionName] != null) {
        return menu[sectionName];
      }
      itemRoot = $("<div>").addClass("ribbon-section");
      itemRoot.append($("<span>").addClass("section-title").text(sectionName));
      menu["__sectionRoot__"].append(itemRoot);
      return menu[sectionName] = {
        __itemRoot__: itemRoot
      };
    };

    ScriptableToolbar.prototype.addMenu = function(name) {
      var tab;
      if (this.menuMap[name] != null) {
        return this.menuMap[name];
      }
      tab = $("<div>").addClass("ribbon-tab");
      tab.append($("<span>").addClass("ribbon-title").text(name));
      this.ribbon.append(tab);
      return this.menuMap[name] = {
        __sectionRoot__: tab
      };
    };

    ScriptableToolbar.prototype.initVisual = function(parent) {
      this.ribbon = $("<div>").addClass("ribbon").append($("<span>").addClass("ribbon-window-title"));
      return parent.append(this.ribbon);
    };

    ScriptableToolbar.prototype.loadLayout = function(data) {
      var itemData, itemName, menu, menuData, name, section, sectionData, sectionName;
      if (typeof data === "string") {
        data = JSON.parse(data);
      }
      for (name in data) {
        menuData = data[name];
        menu = this.addMenu(name);
        for (sectionName in menuData) {
          sectionData = menuData[sectionName];
          section = this.addSection(menu, sectionName);
          for (itemName in sectionData) {
            itemData = sectionData[itemName];
            this.addItem(section, itemName, itemData["href"], itemData["help"], itemData["clear"]);
          }
        }
      }
      return null;
    };

    return ScriptableToolbar;

  })();
});

// Generated by CoffeeScript 1.6.3
define('editor_tools/interpretter',['require'],function(req) {
  var Interpreter;
  return Interpreter = (function() {
    function Interpreter(editor) {
      var _this;
      this.editor = editor;
      _this = this;
      this.env = {};
    }

    Interpreter.prototype.hasImplementation = function(item) {
      return this.env[item] != null;
    };

    Interpreter.prototype.getImplementation = function(cmd) {
      return this.env[cmd];
    };

    Interpreter.prototype.addImplementation = function(cmd, fnc) {
      return this.env[cmd] = fnc;
    };

    Interpreter.prototype.removeImplementation = function(cmd) {
      return delete this.env[cmd];
    };

    Interpreter.prototype.exec = function(script) {
      var e, s;
      try {
        eval("with (this.env) { script(); }");
      } catch (_error) {
        e = _error;
        s = e;
      }
      if ((s != null) && (s.toString != null)) {
        return s.toString();
      }
    };

    Interpreter.prototype.autocomplete = function(string, callback) {
      var prop, results;
      results = [];
      for (prop in this.env) {
        if (prop.indexOf(string) === 0) {
          results.push(prop);
        }
      }
      return callback(results);
    };

    Interpreter.prototype.loadScript = function(editor, env, api) {
      return function(t) {
        return env[api] = function() {
          return t(editor);
        };
      };
    };

    Interpreter.prototype.loadAPI = function(data) {
      var api, editor, env, prop, r;
      if (typeof data === "string") {
        data = JSON.parse(data);
      }
      env = this.env;
      editor = this.editor;
      for (prop in data) {
        api = "scripts/" + prop + "-" + data[prop]["repo"] + "-" + data[prop]["version"] + ".js";
        r = require([require.toUrl(api)], this.loadScript(editor, env, prop));
      }
      return env;
    };

    return Interpreter;

  })();
});

// Generated by CoffeeScript 1.3.3
(function() {
  var Byte, Client, Frame, Stomp,
    __hasProp = {}.hasOwnProperty;

  Byte = {
    LF: '\x0A',
    NULL: '\x00'
  };

  Frame = (function() {

    function Frame(command, headers, body) {
      this.command = command;
      this.headers = headers != null ? headers : {};
      this.body = body != null ? body : '';
    }

    Frame.prototype.toString = function() {
      var lines, name, value, _ref;
      lines = [this.command];
      _ref = this.headers;
      for (name in _ref) {
        if (!__hasProp.call(_ref, name)) continue;
        value = _ref[name];
        lines.push("" + name + ":" + value);
      }
      if (this.body) {
        lines.push("content-length:" + ('' + this.body).length);
      }
      lines.push(Byte.LF + this.body);
      return lines.join(Byte.LF);
    };

    Frame._unmarshallSingle = function(data) {
      var body, chr, command, divider, headerLines, headers, i, idx, len, line, start, trim, _i, _j, _ref, _ref1;
      divider = data.search(RegExp("" + Byte.LF + Byte.LF));
      headerLines = data.substring(0, divider).split(Byte.LF);
      command = headerLines.shift();
      headers = {};
      trim = function(str) {
        return str.replace(/^\s+|\s+$/g, '');
      };
      line = idx = null;
      for (i = _i = 0, _ref = headerLines.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        line = headerLines[i];
        idx = line.indexOf(':');
        headers[trim(line.substring(0, idx))] = trim(line.substring(idx + 1));
      }
      body = '';
      start = divider + 2;
      if (headers['content-length']) {
        len = parseInt(headers['content-length']);
        body = ('' + data).substring(start, start + len);
      } else {
        chr = null;
        for (i = _j = start, _ref1 = data.length; start <= _ref1 ? _j < _ref1 : _j > _ref1; i = start <= _ref1 ? ++_j : --_j) {
          chr = data.charAt(i);
          if (chr === Byte.NULL) {
            break;
          }
          body += chr;
        }
      }
      return new Frame(command, headers, body);
    };

    Frame.unmarshall = function(datas) {
      var data;
      return (function() {
        var _i, _len, _ref, _results;
        _ref = datas.split(RegExp("" + Byte.NULL + Byte.LF + "*"));
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          data = _ref[_i];
          if ((data != null ? data.length : void 0) > 0) {
            _results.push(Frame._unmarshallSingle(data));
          }
        }
        return _results;
      })();
    };

    Frame.marshall = function(command, headers, body) {
      var frame;
      frame = new Frame(command, headers, body);
      return frame.toString() + Byte.NULL;
    };

    return Frame;

  })();

  Client = (function() {

    function Client(ws) {
      this.ws = ws;
      this.ws.binaryType = "arraybuffer";
      this.counter = 0;
      this.connected = false;
      this.heartbeat = {
        outgoing: 10000,
        incoming: 10000
      };
      this.subscriptions = {};
    }

    Client.prototype._transmit = function(command, headers, body) {
      var out;
      out = Frame.marshall(command, headers, body);
      if (typeof this.debug === "function") {
        this.debug(">>> " + out);
      }
      return this.ws.send(out);
    };

    Client.prototype._setupHeartbeat = function(headers) {
      var serverIncoming, serverOutgoing, ttl, v, _ref, _ref1,
        _this = this;
      if ((_ref = headers.version) !== Stomp.VERSIONS.V1_1 && _ref !== Stomp.VERSIONS.V1_2) {
        return;
      }
      _ref1 = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = headers['heart-beat'].split(",");
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          v = _ref1[_i];
          _results.push(parseInt(v));
        }
        return _results;
      })(), serverOutgoing = _ref1[0], serverIncoming = _ref1[1];
      if (!(this.heartbeat.outgoing === 0 || serverIncoming === 0)) {
        ttl = Math.max(this.heartbeat.outgoing, serverIncoming);
        if (typeof this.debug === "function") {
          this.debug("send PING every " + ttl + "ms");
        }
        this.pinger = typeof window !== "undefined" && window !== null ? window.setInterval(function() {
          _this.ws.send(Byte.LF);
          return typeof _this.debug === "function" ? _this.debug(">>> PING") : void 0;
        }, ttl) : void 0;
      }
      if (!(this.heartbeat.incoming === 0 || serverOutgoing === 0)) {
        ttl = Math.max(this.heartbeat.incoming, serverOutgoing);
        if (typeof this.debug === "function") {
          this.debug("check PONG every " + ttl + "ms");
        }
        return this.ponger = typeof window !== "undefined" && window !== null ? window.setInterval(function() {
          var delta;
          delta = Date.now() - _this.serverActivity;
          if (delta > ttl * 2) {
            if (typeof _this.debug === "function") {
              _this.debug("did not receive server activity for the last " + delta + "ms");
            }
            return _this._cleanUp();
          }
        }, ttl) : void 0;
      }
    };

    Client.prototype.connect = function(login, passcode, connectCallback, errorCallback, vhost) {
      var _this = this;
      this.connectCallback = connectCallback;
      if (typeof this.debug === "function") {
        this.debug("Opening Web Socket...");
      }
      this.ws.onmessage = function(evt) {
        var arr, c, data, frame, onreceive, _i, _len, _ref, _results;
        data = typeof ArrayBuffer !== 'undefined' && evt.data instanceof ArrayBuffer ? (arr = new Uint8Array(evt.data), typeof _this.debug === "function" ? _this.debug("--- got data length: " + arr.length) : void 0, ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = arr.length; _i < _len; _i++) {
            c = arr[_i];
            _results.push(String.fromCharCode(c));
          }
          return _results;
        })()).join('')) : evt.data;
        _this.serverActivity = Date.now();
        if (data === Byte.LF) {
          if (typeof _this.debug === "function") {
            _this.debug("<<< PONG");
          }
          return;
        }
        if (typeof _this.debug === "function") {
          _this.debug("<<< " + data);
        }
        _ref = Frame.unmarshall(data);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          frame = _ref[_i];
          switch (frame.command) {
            case "CONNECTED":
              if (typeof _this.debug === "function") {
                _this.debug("connected to server " + frame.headers.server);
              }
              _this.connected = true;
              _this._setupHeartbeat(frame.headers);
              _results.push(typeof _this.connectCallback === "function" ? _this.connectCallback(frame) : void 0);
              break;
            case "MESSAGE":
              onreceive = _this.subscriptions[frame.headers.subscription];
              _results.push(typeof onreceive === "function" ? onreceive(frame) : void 0);
              break;
            case "RECEIPT":
              _results.push(typeof _this.onreceipt === "function" ? _this.onreceipt(frame) : void 0);
              break;
            case "ERROR":
              _results.push(typeof errorCallback === "function" ? errorCallback(frame) : void 0);
              break;
            default:
              _results.push(typeof _this.debug === "function" ? _this.debug("Unhandled frame: " + frame) : void 0);
          }
        }
        return _results;
      };
      this.ws.onclose = function() {
        var msg;
        msg = "Whoops! Lost connection to " + _this.ws.url;
        if (typeof _this.debug === "function") {
          _this.debug(msg);
        }
        return typeof errorCallback === "function" ? errorCallback(msg) : void 0;
      };
      return this.ws.onopen = function() {
        var headers;
        if (typeof _this.debug === "function") {
          _this.debug('Web Socket Opened...');
        }
        headers = {
          "accept-version": Stomp.VERSIONS.supportedVersions(),
          "heart-beat": [_this.heartbeat.outgoing, _this.heartbeat.incoming].join(',')
        };
        if (vhost) {
          headers.host = vhost;
        }
        if (login) {
          headers.login = login;
        }
        if (passcode) {
          headers.passcode = passcode;
        }
        return _this._transmit("CONNECT", headers);
      };
    };

    Client.prototype.disconnect = function(disconnectCallback) {
      this._transmit("DISCONNECT");
      this.ws.onclose = null;
      this._cleanUp();
      return typeof disconnectCallback === "function" ? disconnectCallback() : void 0;
    };

    Client.prototype._cleanUp = function() {
      this.ws.close();
      this.connected = false;
      if (this.pinger) {
        if (typeof window !== "undefined" && window !== null) {
          window.clearInterval(this.pinger);
        }
      }
      if (this.ponger) {
        return typeof window !== "undefined" && window !== null ? window.clearInterval(this.ponger) : void 0;
      }
    };

    Client.prototype.send = function(destination, headers, body) {
      if (headers == null) {
        headers = {};
      }
      if (body == null) {
        body = '';
      }
      headers.destination = destination;
      return this._transmit("SEND", headers, body);
    };

    Client.prototype.subscribe = function(destination, callback, headers) {
      if (headers == null) {
        headers = {};
      }
      if (!headers.id) {
        headers.id = "sub-" + this.counter++;
      }
      headers.destination = destination;
      this.subscriptions[headers.id] = callback;
      this._transmit("SUBSCRIBE", headers);
      return headers.id;
    };

    Client.prototype.unsubscribe = function(id) {
      delete this.subscriptions[id];
      return this._transmit("UNSUBSCRIBE", {
        id: id
      });
    };

    Client.prototype.begin = function(transaction) {
      return this._transmit("BEGIN", {
        transaction: transaction
      });
    };

    Client.prototype.commit = function(transaction) {
      return this._transmit("COMMIT", {
        transaction: transaction
      });
    };

    Client.prototype.abort = function(transaction) {
      return this._transmit("ABORT", {
        transaction: transaction
      });
    };

    Client.prototype.ack = function(messageID, subscription, headers) {
      if (headers == null) {
        headers = {};
      }
      headers["message-id"] = messageID;
      headers.subscription = subscription;
      return this._transmit("ACK", headers);
    };

    Client.prototype.nack = function(messageID, subscription, headers) {
      if (headers == null) {
        headers = {};
      }
      headers["message-id"] = messageID;
      headers.subscription = subscription;
      return this._transmit("NACK", headers);
    };

    return Client;

  })();

  Stomp = {
    libVersion: "2.0.0-next",
    VERSIONS: {
      V1_0: '1.0',
      V1_1: '1.1',
      V1_2: '1.2',
      supportedVersions: function() {
        return '1.1,1.0';
      }
    },
    client: function(url, protocols) {
      var klass, ws;
      if (protocols == null) {
        protocols = ['v10.stomp', 'v11.stomp'];
      }
      klass = Stomp.WebSocketClass || WebSocket;
      ws = new klass(url, protocols);
      return new Client(ws);
    },
    over: function(ws) {
      return new Client(ws);
    },
    Frame: Frame
  };

  if (typeof window !== "undefined" && window !== null) {
    window.Stomp = Stomp;
  } else {
    exports.Stomp = Stomp;
    Stomp.WebSocketClass = require('./test/server.mock.js').StompServerMock;
  }

}).call(this);

define("stomp", function(){});

define('xml2json',[],function() {

function json2xml(o, tab) {
   var toXml = function(v, name, ind) {
      var xml = "";
      if (v instanceof Array) {
         for (var i=0, n=v.length; i<n; i++)
            xml += ind + toXml(v[i], name, ind+"\t") + "\n";
      }
      else if (typeof(v) == "object") {
         var hasChild = false;
         xml += ind + "<" + name;
         for (var m in v) {
            if (m.charAt(0) == "@")
               xml += " " + m.substr(1) + "=\"" + v[m].toString() + "\"";
            else
               hasChild = true;
         }
         xml += hasChild ? ">" : "/>";
         if (hasChild) {
            for (var m in v) {
               if (m == "#text")
                  xml += v[m];
               else if (m == "#cdata")
                  xml += "<![CDATA[" + v[m] + "]]>";
               else if (m.charAt(0) != "@")
                  xml += toXml(v[m], m, ind+"\t");
            }
            xml += (xml.charAt(xml.length-1)=="\n"?ind:"") + "</" + name + ">";
         }
      }
      else {
         xml += ind + "<" + name + ">" + v.toString() +  "</" + name + ">";
      }
      return xml;
   }, xml="";
   for (var m in o)
      xml += toXml(o[m], m, "");
   return tab ? xml.replace(/\t/g, tab) : xml.replace(/\t|\n/g, "");
}


function parseXml(xml) {
   var dom = null;
   if (window.DOMParser) {
      try { 
         dom = (new DOMParser()).parseFromString(xml, "text/xml"); 
      } 
      catch (e) { dom = null; }
   }
   else if (window.ActiveXObject) {
      try {
         dom = new ActiveXObject('Microsoft.XMLDOM');
         dom.async = false;
         if (!dom.loadXML(xml)) // parse error ..
            window.alert(dom.parseError.reason + dom.parseError.srcText);
      } 
      catch (e) { dom = null; }
   }
   else
      alert("oops");
   return dom;
}

/*	This work is licensed under Creative Commons GNU LGPL License.

	License: http://creativecommons.org/licenses/LGPL/2.1/
   Version: 0.9
	Author:  Stefan Goessner/2006
	Web:     http://goessner.net/ 
*/
function xml2json(xml, tab) {
   xml = parseXml(xml);
   var X = {
      toObj: function(xml) {
         var o = {};
         if (xml.nodeType==1) {   // element node ..
            if (xml.attributes.length)   // element with attributes  ..
               for (var i=0; i<xml.attributes.length; i++)
                  o["@"+xml.attributes[i].nodeName] = (xml.attributes[i].nodeValue||"").toString();
            if (xml.firstChild) { // element has child nodes ..
               var textChild=0, cdataChild=0, hasElementChild=false;
               for (var n=xml.firstChild; n; n=n.nextSibling) {
                  if (n.nodeType==1) hasElementChild = true;
                  else if (n.nodeType==3 && n.nodeValue.match(/[^ \f\n\r\t\v]/)) textChild++; // non-whitespace text
                  else if (n.nodeType==4) cdataChild++; // cdata section node
               }
               if (hasElementChild) {
                  if (textChild < 2 && cdataChild < 2) { // structured element with evtl. a single text or/and cdata node ..
                     X.removeWhite(xml);
                     for (var n=xml.firstChild; n; n=n.nextSibling) {
                        if (n.nodeType == 3)  // text node
                           o["#text"] = X.escape(n.nodeValue);
                        else if (n.nodeType == 4)  // cdata node
                           o["#cdata"] = X.escape(n.nodeValue);
                        else if (o[n.nodeName]) {  // multiple occurence of element ..
                           if (o[n.nodeName] instanceof Array)
                              o[n.nodeName][o[n.nodeName].length] = X.toObj(n);
                           else
                              o[n.nodeName] = [o[n.nodeName], X.toObj(n)];
                        }
                        else  // first occurence of element..
                           o[n.nodeName] = X.toObj(n);
                     }
                  }
                  else { // mixed content
                     if (!xml.attributes.length)
                        o = X.escape(X.innerXml(xml));
                     else
                        o["#text"] = X.escape(X.innerXml(xml));
                  }
               }
               else if (textChild) { // pure text
                  if (!xml.attributes.length)
                     o = X.escape(X.innerXml(xml));
                  else
                     o["#text"] = X.escape(X.innerXml(xml));
               }
               else if (cdataChild) { // cdata
                  if (cdataChild > 1)
                     o = X.escape(X.innerXml(xml));
                  else
                     for (var n=xml.firstChild; n; n=n.nextSibling)
                        o["#cdata"] = X.escape(n.nodeValue);
               }
            }
            if (!xml.attributes.length && !xml.firstChild) o = null;
         }
         else if (xml.nodeType==9) { // document.node
            o = X.toObj(xml.documentElement);
         }
         else
            alert("unhandled node type: " + xml.nodeType);
         return o;
      },
      toJson: function(o, name, ind) {
         var json = name ? ("\""+name+"\"") : "";
         if (o instanceof Array) {
            for (var i=0,n=o.length; i<n; i++)
               o[i] = X.toJson(o[i], "", ind+"\t");
            json += (name?":[":"[") + (o.length > 1 ? ("\n"+ind+"\t"+o.join(",\n"+ind+"\t")+"\n"+ind) : o.join("")) + "]";
         }
         else if (o == null)
            json += (name&&":") + "null";
         else if (typeof(o) == "object") {
            var arr = [];
            for (var m in o)
               arr[arr.length] = X.toJson(o[m], m, ind+"\t");
            json += (name?":{":"{") + (arr.length > 1 ? ("\n"+ind+"\t"+arr.join(",\n"+ind+"\t")+"\n"+ind) : arr.join("")) + "}";
         }
         else if (typeof(o) == "string")
            json += (name&&":") + "\"" + o.toString() + "\"";
         else
            json += (name&&":") + o.toString();
         return json;
      },
      innerXml: function(node) {
         var s = ""
         if ("innerHTML" in node)
            s = node.innerHTML;
         else {
            var asXml = function(n) {
               var s = "";
               if (n.nodeType == 1) {
                  s += "<" + n.nodeName;
                  for (var i=0; i<n.attributes.length;i++)
                     s += " " + n.attributes[i].nodeName + "=\"" + (n.attributes[i].nodeValue||"").toString() + "\"";
                  if (n.firstChild) {
                     s += ">";
                     for (var c=n.firstChild; c; c=c.nextSibling)
                        s += asXml(c);
                     s += "</"+n.nodeName+">";
                  }
                  else
                     s += "/>";
               }
               else if (n.nodeType == 3)
                  s += n.nodeValue;
               else if (n.nodeType == 4)
                  s += "<![CDATA[" + n.nodeValue + "]]>";
               return s;
            };
            for (var c=node.firstChild; c; c=c.nextSibling)
               s += asXml(c);
         }
         return s;
      },
      escape: function(txt) {
         return txt.replace(/[\\]/g, "\\\\")
                   .replace(/[\"]/g, '\\"')
                   .replace(/[\n]/g, '\\n')
                   .replace(/[\r]/g, '\\r');
      },
      removeWhite: function(e) {
         e.normalize();
         for (var n = e.firstChild; n; ) {
            if (n.nodeType == 3) {  // text node
               if (!n.nodeValue.match(/[^ \f\n\r\t\v]/)) { // pure whitespace text node
                  var nxt = n.nextSibling;
                  e.removeChild(n);
                  n = nxt;
               }
               else
                  n = n.nextSibling;
            }
            else if (n.nodeType == 1) {  // element node
               X.removeWhite(n);
               n = n.nextSibling;
            }
            else                      // any other node
               n = n.nextSibling;
         }
         return e;
      }
   };
   if (xml.nodeType == 9) // document node
      xml = xml.documentElement;
   var json = X.toJson(X.toObj(X.removeWhite(xml)), xml.nodeName, "\t");

   return JSON.parse("{" + json + "}");
}

return {
   xml2json : xml2json,
   json2xml : json2xml
}
});
// Generated by CoffeeScript 1.6.3
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

define('editor_tools/sally_client',['require','stomp','xml2json'],function(require) {
  var SallyClient, connections, createRegisterDocument, xml2json;
  require("stomp");
  xml2json = require("xml2json");
  createRegisterDocument = function(docQueue, envid, interfaces) {
    return {
      "registerdocument": {
        "@xmlns": "http://kwarc.info/sally/comm/core",
        "documentqueue": docQueue,
        "environmentid": envid,
        "interfaces": interfaces
      }
    };
  };
  connections = {};
  return SallyClient = (function() {
    function SallyClient(config, msgHandler) {
      this.config = config;
      this.msgHandler = msgHandler;
      this.stompMsgHandler = __bind(this.stompMsgHandler, this);
      this.registerDocument = __bind(this.registerDocument, this);
      if (connections[config.stompUrl] != null) {
        this.stompClient = connections[config.stompUrl];
      } else {
        this.stompClient = Stomp.client(config.stompUrl);
        connections[config.stompUrl] = this.stompClient;
        this.stompClient.connect(config.stompUser, config.stompPassword, (function(frame) {
          return jQuery(this.stompClient.connection_div).trigger("onConnected");
        }).bind(this));
      }
    }

    SallyClient.prototype.registerDocument = function(interfaces, envid, callback) {
      var msg,
        _this = this;
      msg = createRegisterDocument(this.privateQueue, envid, interfaces);
      return this.send("/queue/sally_register", msg, function(msg) {
        _this.sally_queue = msg["registerdocumentresponse"]["sallyqueue"];
        return callback();
      });
    };

    SallyClient.prototype.connect = function(interfaces, envid, callback) {
      var client,
        _this = this;
      this.interfaces = interfaces;
      client = this.stompClient;
      if (client.connected) {
        return callback();
      }
      if (client.connection_div == null) {
        client.connection_div = jQuery("<div>");
      }
      return jQuery(client.connection_div).bind("onConnected", function(e) {
        _this.privateQueue = "editor_tools_" + Math.floor(Math.random() * 100000);
        _this.stompClient.subscribe("/queue/" + _this.privateQueue, _this.stompMsgHandler);
        return _this.registerDocument(_this.interfaces, envid, callback);
      });
    };

    SallyClient.prototype.sendSally = function(msg, callback, headers) {
      return this.send(this.sally_queue, msg, callback, headers);
    };

    SallyClient.prototype.send = function(destination, msg, callback, headers) {
      var corrid, queue_post, sub,
        _this = this;
      console.log(msg);
      if (typeof msg === "object") {
        msg = xml2json.json2xml(msg);
      }
      if (callback != null) {
        corrid = Math.random();
        queue_post = "/temp-queue/editor_exchange" + corrid;
        sub = this.stompClient.subscribe(queue_post, function(msg) {
          var body;
          body = xml2json.xml2json(msg.body);
          if ((body.html == null) && callback(body, msg) === true) {
            return;
          }
          return _this.stompClient.unsubscribe(corrid);
        }, {
          "id": corrid
        });
        if (headers == null) {
          headers = {};
        }
        headers["reply-to"] = queue_post;
        headers["correlation-id"] = corrid;
      }
      console.log("sending to ", destination, " msg ", msg);
      return this.stompClient.send(destination, headers, msg.toString());
    };

    SallyClient.prototype.stompMsgHandler = function(msg) {
      var body,
        _this = this;
      body = xml2json.xml2json(msg.body);
      if ((body["heartbeatrequest"] != null) && body["heartbeatrequest"]["@xmlns"] === "http://kwarc.info/sally/comm/core") {
        this.send(msg.headers["reply-to"], {
          "heartbeatresponse": {
            "@xmlns": "http://kwarc.info/sally/comm/core"
          }
        }, null, {
          "correlation-id": msg.headers["correlation-id"]
        });
        return;
      }
      return this.msgHandler(body, msg, function(sendBack) {
        return _this.send(msg.headers["reply-to"], sendBack, null, {
          "correlation-id": msg.headers["correlation-id"]
        });
      });
    };

    return SallyClient;

  })();
});

// Generated by CoffeeScript 1.6.3
define('editor_tools/main',['require','editor_tools/scriptable_toolbar','editor_tools/interpretter','editor_tools/sally_client'],function(require) {
  var $, Interpretter, SallyClient, Toolbar, planetaryNS, textNS;
  if (typeof $ === "undefined" || $ === null) {
    $ = jQuery;
  }
  Toolbar = require("editor_tools/scriptable_toolbar");
  Interpretter = require("editor_tools/interpretter");
  SallyClient = require("editor_tools/sally_client");
  planetaryNS = "http://kwarc.info/sally/comm/planetaryclient";
  textNS = "http://kwarc.info/sally/comm/planetaryclient";
  return {
    enrich_editor: function(editor, id, config) {
      var handler, header, interpretter, layout, sallyclient, terminal, toolbar, wrapped,
        _this = this;
      this.editor = editor;
      if (config == null) {
        config = {};
      }
      this.id = id;
      config = $.extend({
        root_path: "",
        stompUrl: "ws://mathhub.info:61614",
        stompUser: "webclient",
        stompPassword: "webclient",
        envid: "random_edit" + Math.random(),
        servletAddress: "http://mathhub.info:8181",
        sid: ""
      }, config);
      handler = function(body, msg, response) {
        var MHWSection, homeMenu;
        if ((body["GetDocumentMeta"] != null) && body["GetDocumentMeta"]["@xmlns"] === planetaryNS) {
          response({
            "GetDocumentMetaResponse": {
              "@xmlns": planetaryNS,
              "sessionid": config.sid,
              "filepath": config.file
            }
          });
        }
        if (body.NewService != null) {
          interpretter.addImplementation(body.NewService.id, function() {
            var dv;
            dv = $("<div>").append($("<iframe>").attr("src", body.NewService.url).attr("style", "width:100%;height:auto"));
            return $(dv).dialog();
          });
          homeMenu = toolbar.addMenu("Home");
          MHWSection = toolbar.addSection(homeMenu, "MathHub services");
          toolbar.addItem(MHWSection, body.NewService.id, body.NewService.icon);
        }
        if (body.RemoveService != null) {
          interpretter.removeImplementation(body.RemoveService.id);
          homeMenu = toolbar.addMenu("Home");
          MHWSection = toolbar.addSection(homeMenu, "MathHub services");
          return toolbar.removeItem(MHWSection, body.RemoveService.id);
        }
      };
      sallyclient = new SallyClient(config, handler);
      editor.sallyclient = sallyclient;
      ace.config.loadModule("ace/ext/language_tools", function(tools) {
        editor.setOptions({
          enableBasicAutocompletion: true
        });
        return tools.addCompleter({
          getCompletions: function(editor, session, pos, prefix, callback) {
            var responseCallback;
            pos = editor.getCursorPosition();
            responseCallback = function(_msg) {
              var msg, res;
              _msg = _msg.AutocompleteResponse;
              if ((_msg == null) || (_msg.suggestion == null)) {
                return true;
              }
              if (!_msg.hasOwnProperty("length")) {
                msg = [_msg.suggestion];
              } else {
                msg = _msg.suggestion;
              }
              res = msg.map(function(suggestion) {
                var trimLen, trimmedConcept;
                trimmedConcept = suggestion.concept;
                trimLen = 30;
                if (trimmedConcept.length > trimLen) {
                  trimmedConcept = "..." + trimmedConcept.substr(trimmedConcept.length - trimLen, trimLen);
                }
                return {
                  name: suggestion.text,
                  value: suggestion.text,
                  caption: trimmedConcept,
                  completer: {
                    insertMatch: function(editor) {
                      return editor.execCommand("insertstring", "\\trefi{" + suggestion.text + "}");
                    }
                  },
                  meta: "remote"
                };
              });
              callback(null, res);
              return true;
            };
            return sallyclient.sendSally({
              "AutocompleteRequest": {
                "@xmlns": textNS,
                "text": editor.getValue(),
                "line": pos.row,
                "col": pos.column,
                "path": config.file,
                "prefix": prefix
              }
            }, responseCallback);
          }
        });
      });
      wrapped = $(id).wrap("<div>").parent();
      $(id).addClass("ui-layout-center");
      header = $("<div>").addClass("ui-layout-north");
      terminal = $("<div>").addClass("ui-layout-south");
      wrapped.prepend(header);
      wrapped.append(terminal);
      layout = null;
      interpretter = new Interpretter(this.editor);
      toolbar = new Toolbar(header, interpretter, config.root_path);
      sallyclient.connect(["planetaryclient", "theo"], config.envid, function() {
        return console.log("connected");
      });
      return {
        toolbar: toolbar,
        interpretter: interpretter,
        editor: this.editor,
        header: header
      };
    }
  };
});
